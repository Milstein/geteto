\documentclass [a4paper, 12pt]{article}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[verbose,left=25mm,right=25mm,top=25mm,bottom=25mm]{geometry}
\usepackage{epsfig}
\usepackage{longtable}
\usepackage{color}
\usepackage{ae}
\pagestyle{plain} %numeração no pé da pagina

\newcommand{\dela}[1]{{\color{red} #1}}

\title{Métricas a serem implementadas.}


\begin{document}

\maketitle
\section{Métricas de LK}


\subsection{Número de métodos de instância públicos na classe -
\textit{Number of public instance methods in a class} -
NPIM}

Métrica calculada através da contagem do número de métodos de
instância públicas na classe, incluindo os construtores.


\subsection{Número de variáveis de instância na classe -
\textit{Number of instance variables in a class} - NIV}

Métrica calculada através da contagem do número de variáveis de
instância na classe, o que inclui as variáveis \textit{public},
\textit{private} e \textit{protected} disponíveis para as
instâncias.


\subsection{Número de métodos de classe na classe -
\textit{Number of class methods in a class} - NCM}

Métrica calculada através da contagem do número de métodos
\textit{static} na classe.

Variação: contar apenas os métodos estáticos e públicos. Esta
metrica será chamada NCM\_2


\subsection{Número de variáveis de classe na classe - \textit{Number of class
variables in a class} - NCV}

Métrica calculada através da contagem do número de variáveis
\textit{static} na classe.



\subsection{Número médio de parâmetros por método - \textit{Average number of
parameters per method} - ANPM}

Métrica calculada através da divisão entre o somatório do número
de parâmetros de cada método da classe pelo número total de
métodos da classe.

Variação: número máximo de parâmetros em um método da classe (Max
number of parameters per method - MNPM).


\subsection{Tamanho médio do método - \textit{Average method size} -
AMZ\_LOCM}

Métrica calculada através da divisão entre a soma do número de
linhas de código dos métodos da classe pelo número de métodos na
classe (soma dos métodos instância e classe) .

Variações: média do número de instruções do bytecode (AMZ\_SIZE)


\subsection{Uso de herança múltipla - \textit{Use of multiple inheritance} -
UMI}

Como a herança múltipla não se aplica à linguagem JAVA será
definida uma variação à esta métrica.

Variação: número de interfaces implementadas pela classe
(\textit{Number of interfaces implemented} - NII).


\subsection{Número de métodos sobrescritos na subclasse - \textit{Number of
methods overridden by a subclass} - NMOS}

Métrica calculada através da contagem do número de métodos
definidos na subclasse com a mesma assinatura de um método na sua
superclasse.

\subsection{Número de métodos herdados pela subclasse - \textit{Number of
methods inherited by a subclass} - NMIS}

Métrica calculada através da contagem do número de métodos
herdados pela subclasse de suas superclasses.


\subsection{Número de métodos adicionados pela subclasse - \textit{Number of
methods added by a subclass} - NMAS}

Métrica calculada através da contagem do número de novos métodos
adicionados pela classe.

Obs: Para as três métricas acima são consideradas somente as
classes definidas dentro da estrutura do programa. Ou seja, uma
class A cuja superclasse esteja fora da estrutura de intereesa
para o programa sendo analisado terá os seguintes valores para
essas métricas:

\begin{description}
\item[NMOS:] zero como se todos os métodos definidos em A fossem novos;
\item[NMAS:] número de métodos definidos em A;
\item[NMIS:] zero.
\end{description}

Isso porque nem sempre se tem acesso às classes fora da estrutura
do programa.

\subsection{Índice de Especialização - \textit{Specialization index} - SI}

Métrica calculada através da divisão entre o resultado da
multiplicação de NMOS e DIT (métrica de CK) pelo número total de métodos.



\section{Métricas de CK}



\subsection{Número de Filhos - \textit{Number of Children} - NOC}

Métrica calculada através da contagem do número de subclasses
imediatas subordinadas à classe na árvore de hierarquia.

\subsection{Profundidade da Árvore de Herança - \textit{Depth of Inheritance
Tree} - DIT}

É o maior caminho da classe à raiz na árvore de hierarquia de
herança. Interfaces também são consideradas, ou seja, o caminho
através de uma hierarquia de interfaces também pode ser o que dá a
profundidade de uma classe.

Variação: como a representação de programa utilizada não inclui
todas as classes até a raiz da árvore de hierarquia, será
utilizado o caminho da classe até a primeira classe que não
pertence à estrutura do programa.


\subsection{Número de métodos ponderados por classe - \textit{Weighted Methods
per Class} - WMC}

 Métrica calculada através da soma da complexidade de cada método.
 Não se define qual tipo de complexidade pode ser utilizada, assim
 serão aplicadas as seguintes variações:

 \begin{itemize}
 \item Utiliza-se o valor 1 como complexidade de cada método;
 assim WMC\_1 é o numero de métodos na classe;
 \item Utiliza-se a métrica CC para a complexidade de cada método;
 esta métrica será chamada WMC\_CC;
 \item Utiliza-se a métrica LOCM (linhas de código)
 para a complexidade de cada método;
 esta métrica será chamada WMC\_LOCM;
 \item Utiliza-se o tamanho do método (número de instruções)
 para a complexidade de cada método;
 esta métrica será chamada WMC\_SIZE;
 \end{itemize}

\subsection{Falta de Coesão entre os métodos - \textit{Lack of Cohesion in
Methods} - LCOM}

Métrica calculada através da contagem do número de pares de
métodos na classe que não compartilham variáveis de instância
menos o número de pares de métodos que compartilham variáveis de
instância. Quando o resultado é negativo, a métrica recebe o valor
zero. Os métodos estáticos não são considerados na contagem, uma
vez que só as variáveis de instância são tomadas.

Variações:
\begin{itemize}
\item Considerar só a coesão entre métodos estáticos; esta métrica
será chamada LCOM\_2;
\item Considerar a coesão de métodos estáticos ou de instância;
esta métrica, chamada LCOM\_3 pode ser calculada como $LCOM -
LCOM\_2$;
\end{itemize}



\subsection{Resposta para uma classe - \textit{Response for a Class} - RFC}

Métrica calculada através da soma do número de métodos da classe
mais os métodos que são invocados diretamente por eles. É o número
de métodos que podem ser potencialmente executados em resposta a
uma mensagem recebida por um objeto de uma classe ou por algum
método da classe. Quando um método polimórfico é chamado para
diferentes classes, cada diferente chamada é contada uma vez.


\subsection{Acoplamento entre objetos - \textit{Coupling Between Object} - CBO}

Há acoplamento entre duas classes quando uma classe usa métodos
e/ou variáveis de instância de outra classe. Métrica calculada
através da contagem do número de classes às quais uma classe está
acoplada de alguma forma. O valor CBO de uma classe A é o número
de classes das quais a classe A utiliza algum método e/ou variável
de instância, o que inclui o acoplamento baseado em herança, visto
que um construtor da superclasse é sempre chamado no construtor de
A.


\section{Outras Métricas}


\subsection{Complexidade Ciclomática de McCabe - \textit{Cyclomatic Complexity
Metric} - CC}

Métrica que calcula a complexidade do método, através dos grafos de fluxo de
controle que descreve a estrutura lógica do método.

Os grafos de fluxo consistem de nós e ramos, onde os nós representam comandos
ou expressões e os ramos representam a transferência de controle entre estes nós.

A métrica pode ser calculada das seguintes formas:

\begin{itemize}

\item O número de regiões do grafo de fluxo corresponde à Complexidade Ciclomática;

\item A Complexidade Ciclomática, V(G), para o grafo de fluxo G é definida como:

\begin{center}

V(G) = E - N + 2

\end{center}

onde, V(G) mede os caminhos linearmente independentes encontrados no grafo, E é o
número de ramos do grafo de fluxo e N o número de nós.

\item A Complexidade Ciclomática, V(G), para o grafo de fluxo G é definida como:

\begin{center}

V(G) = P(G)+1

\end{center}

onde, P(G) é o número de nós predicativos contidos no grafo de
fluxo G. Os nós predicativos são comandos condicionais
(\textit{if}, \textit{while}, ...) com um ou mais operadores
booleanos (\textit{or}, \textit{and}, \textit{nand},
\textit{nor}). Um nó é criado para cada nó `a' ou `b' de um
comando \verb+IF a OR b+.

\end{itemize}

Outras formas de se calcular a Complexidade Ciclomática são:

\begin{itemize}

\item V(G) = número de regiões de G;

\item V(G) = número de ramos - número de nós + 2;

\item V(G) = número de nós predicativos + 1.

\end{itemize}

Variações: a métrica é aplicada a métodos mas pode ser aplica à
classe através da soma (ver WMC\_CC), da média (que será chamada
CC\_AVG) e do máximo (CC\_MAX) entre os métodos.


\end{document}
