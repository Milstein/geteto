Here is an explanation of the aspect example I found on the web.

Attached is a directory with the benchmark program in
  SimulatorWithNullCheckAspectFixed/src/certrevsim/ and
  SimulatorWithNullCheckAspectFixed/src/jsim/

and the "fixed" aspect in
  SimulatorWithNullCheckAspectFixed/src/lib/aspects/codingstandards/

The entry point is certrevsim/Simulator,  and you can compile it with
Java by including just the first two directories,  or with AspectJ by
including the third one too.
   

The original web page can be found at:

http://www.daleasberry.com/newsletters/200210/20021002.shtml

The author, R Dale Asberry (whoever he is?) has written a short article
about using aspects to implement and enforce coding standards.  Some
of these are just aspects that can be checked statically, but he gives
some examples of run-time coding standards as well.   Here is the 
key extract from his article.

------------------------------------------------------------------------

One particularly nasty type of bug to track down occurs when programmers use
the "on error condition, return null from method" anti-pattern.  The reason
this is an anti-pattern is two-fold: all calls to the method that are not
wrapped by error handling code will cause a latent NullPointerException, and,
the error handling code must be found and updated manually everywhere it
is used.  The preferred technique is to have the method throw an exception
with as much context as possible to describe the error condition.  To avoid
copying exception handling code everywhere the method is called, an aspect
can be written that will consistently handle the error.  Here is a snippet
which detects the anti-pattern and outputs a message to the error console:

//The first primitive pointcut matches all calls,
//The second avoids those that have a void return type.
pointcut methodsThatReturnObjects():
  call(* *.*(..)) && !call(void *.*(..));

Object around(): methodsThatReturnObjects()
{ Object lRetVal = proceed();
  if (lRetVal == null)
    { System.err.println(
          "Detected null return value after calling " + 
          thisJoinPoint.getSignature().toShortString() + 
          " in file " + 
          thisJoinPoint.getSourceLocation().getFileName() +
          " at line " + 
          thisJoinPoint.getSourceLocation().getLine()
          );
     }
   return lRetVal;
}

------------------------------------------------------------------------

Since this seemed like a simple aspect to apply to any program,  I picked
a simulator program that had been submitted in Winter 2003.   Here is
a brief description of the benchmark, as submitted by the student.

Certrevsim is a program that simulates the performance of various certificate
revocation schemes using Java.  Depending on the value given to the <Size> and
<TimeSpan> parameters, it can allocate a great many objects, hence making it
suitable as a benchmark.  Note, the other parameters basically only tune the
revocation scheme used in the simulation, and shouldn't impact our optimization
goals.  For more info go to http://www.pvv.ntnu.no/~andrearn/certrev/sim.html

I modified it slightly so that it always starts from the same random number
seed (and is thus deterministic).    

A reasonable run is called by:

     certrevsim.Simulator 100 1400 90 5 60 1 1

-------------------------------------------------------------------------

When I applied the aspect I was VERY surprised to see the amount of code
generated to handle this aspect,  and I was also very surprised to see
the increase in running time.    On musketeer it takes only 1.3 seconds
to run the original simulation,  but 30.4 seconds to run the simulation
with the aspect applied.    I think it is not reasonable to slow down
a program by 25 times,  just to check to see if methods are returning null
values.  

I then decompiled the class files produced by aspectJ,  and to my surprise
I found that the around advice had been applied to all method class return
any kind of value (include base types like int, double, ...).   According
to the comments in the aspect code,  and the fact that one has the
test ...  (lRetVal == null),  one would expect that it would only work
for methods returning Objects.     However, the aspectJ compiler does
not complain about it,  and happily puts the around advice everything,
packaging the base types in containers and so on.

However, it is really a bug in the pointcut, it should really only
be picking out method calls returning something of type or subtype of Object,
so I fixed it by using:

pointcut methodsThatReturnObjects():
  call(Object+ *.*(..)) && !call(void *.*(..));

where I used Object+ instead of * as in the original.    I guess the
second clause is actually superfluous now, but I left it there.

With this fixed one,  the running time is around 9.8 seconds,  still a
slowdown of about 7x - and still bad!

-------------------------------------------------------------------------

So, now let's look at a small example and see what is happening.  Consider
the following two small classes,  Test.java and MyInteger.java.

public class Test {
    public static void main(String[] args) {
      MyInteger one = new MyInteger(1);
      MyInteger two = one.incr(1);
      MyInteger ten = one.incr(9);
      System.out.println("ten is " + ten);
    }
}

public class MyInteger {

    private int myValue;

    public MyInteger(int i) {
      myValue = i;
    }

    public int getValue() {
      return(myValue);
    }

    public String toString() {
      return("<myValue: " + myValue +">");
    }

    public MyInteger incr(int k) {
      return(new MyInteger(myValue + k));
    }
}

When I compile this with the aspectJ compiler that comes with eclipse,
it produces the following files:

MyInteger$AjcClosure1.class
MyInteger$AjcClosure3.class
MyInteger$AjcClosure5.class
MyInteger.class

Test$AjcClosure1.class
Test$AjcClosure3.class
Test$AjcClosure5.class
Test$AjcClosure7.class
Test.class

./lib/aspects/codingstandards:
EnforceCodingStandards$AjcClosure1.class
EnforceCodingStandards$AjcClosure11.class
EnforceCodingStandards$AjcClosure13.class
EnforceCodingStandards$AjcClosure15.class
EnforceCodingStandards$AjcClosure17.class
EnforceCodingStandards$AjcClosure19.class
EnforceCodingStandards$AjcClosure21.class
EnforceCodingStandards$AjcClosure3.class
EnforceCodingStandards$AjcClosure5.class
EnforceCodingStandards$AjcClosure7.class
EnforceCodingStandards$AjcClosure9.class
EnforceCodingStandards.class

So, you can see that it produces a bunch of classes to implement closures,
one closure for each method call that has had advice put around it.

Also note that it put the advice around calls within its own code
(EnforceCodingStandards) .... probably not what you really want.  However,
I couldn't get it to avoid those.   I tried adding
  !(within EnforceCodingStandards) ...  but that didn't work.

I then decompiled the generated class files using Soot,   producing 
.java files for each of the above.

Here is Test.java after the aspect stuff has been woven in.  I have
formatted it a bit and added some comments.

-------------------------------------------------------------

import org.aspectj.runtime.reflect.*;
import lib.aspects.codingstandards.*;
import java.io.*;
import org.aspectj.runtime.internal.*;
import org.aspectj.lang.*;

public class Test
{
    public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0;
    public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1;
    public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2;
    public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3;

    static
    {
        org.aspectj.runtime.reflect.Factory r1;

        r1 = new Factory("Test.java", Class.forName("Test"));
        ajc$tjp_0 = r1.makeSJP("method-call", 
           r1.makeMethodSig("1-incr-MyInteger-int:-k:--MyInteger-"), 10);
        ajc$tjp_1 = r1.makeSJP("method-call", 
           r1.makeMethodSig("1-incr-MyInteger-int:-k:--MyInteger-"), 11);
        ajc$tjp_2 = r1.makeSJP("method-call", 
           r1.makeMethodSig("21-append-java.lang.StringBuffer-java.lang.Object:-arg0:--java.lang.StringBuffer-"), 12);
        ajc$tjp_3 = r1.makeSJP("method-call", 
           r1.makeMethodSig("1-toString-java.lang.StringBuffer----java.lang.String-"), 12);
    }

    static final MyInteger incr_aroundBody0(MyInteger r0, int i0)
    {
        return r0.incr(i0);
    }

    static final MyInteger incr_aroundBody2(MyInteger r0, int i0)
    {
        return r0.incr(i0);
    }

    static final java.lang.StringBuffer 
        append_aroundBody4(java.lang.StringBuffer r0, java.lang.Object r1)
    {
        return r0.append(r1);
    }

    static final java.lang.String 
        toString_aroundBody6(java.lang.StringBuffer r0)
    {
        return r0.toString();
    }

    public static void main(java.lang.String[] r0) throws java.lang.ClassNotFoundException, java.lang.Throwable
    {
        MyInteger r2, r3, r5, r6, r8, r9;
        int i0, i1;
        java.lang.Object[] r4, r7, r11, r13;
        java.lang.StringBuffer r10, r12;
        lib.aspects.codingstandards.EnforceCodingStandards $r14, $r19, $r26, $r30;
        java.io.PrintStream $r24;

        //  MyInteger one = new MyInteger(1);
        r2 = new MyInteger(1);

        //  MyInteger two = one.incr(1);
        i0 = 1;
        r3 = r2;
        $r14 = EnforceCodingStandards.aspectOf();
        r4 = new Object[2];
        r4[0] = r3;
        r4[1] = Conversions.intObject(i0);
        r5 = (MyInteger) $r14.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(new Test$AjcClosure1(r4), ajc$tjp_0);

        //  MyInteger ten = one.incr(9);
        i1 = 9;
        r6 = r2;
        $r19 = EnforceCodingStandards.aspectOf();
        r7 = new Object[2];
        r7[0] = r6;
        r7[1] = Conversions.intObject(i1);
        r8 = (MyInteger) $r19.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(new Test$AjcClosure3(r7), ajc$tjp_1);

        //  System.out.println("ten is " + ten);
        $r24 = System.out;
        r9 = r8;
        r10 = new StringBuffer("ten is ");
        $r26 = EnforceCodingStandards.aspectOf();
        r11 = new Object[2];
        r11[0] = r10;
        r11[1] = r9;
        r12 = (StringBuffer) $r26.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(new Test$AjcClosure5(r11), ajc$tjp_2);
        $r30 = EnforceCodingStandards.aspectOf();
        r13 = new Object[1];
        r13[0] = r12;
        $r24.println((String) $r30.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(new Test$AjcClosure7(r13), ajc$tjp_3));
        return;
    }

}

--------------------------------------------------------------------------

You can see that it is doing heaps of overhead for each call, creating
an array of objects for each call that contains the arguments,  boxing
base types,  then creating a closure,  calling the around method, which
calls the orginal method.      Let's look at one example in more detail,
the line "MyInteger two = one.incr(1);".

        //  MyInteger two = one.incr(1);
        i0 = 1;
        r3 = r2;
        $r14 = EnforceCodingStandards.aspectOf();
        r4 = new Object[2];
        r4[0] = r3;
        r4[1] = Conversions.intObject(i0);
        r5 = (MyInteger) $r14.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(new Test$AjcClosure1(r4), ajc$tjp_0);

where:

======  EnforceCodingStandards.aspectOf();  is

 public static lib.aspects.codingstandards.EnforceCodingStandards aspectOf() 
    throws java.lang.ClassNotFoundException
    { lib.aspects.codingstandards.EnforceCodingStandards $r0;

       $r0 = ajc$perSingletonInstance;
        if ($r0 == null)
        { throw new NoAspectBoundException();
        }
        else
        { return $r0;
        }
    }

======   Conversions.intObject(i0);  is

 public static java.lang.Object intObject(int i0)
    { return new Integer(i0);
    }

======   new Test$AjcClosure1(r4)  is

 public Test$AjcClosure1(java.lang.Object[] r1)
    { super(r1);
      return;
    }

======   where the super constructor is in
      org.aspectj.runtime.internal.AroundClosure  and is:

  public AroundClosure(java.lang.Object[] r1)
    { super();
      state = r1;
      return;
    }

  and the super constructor call is the one in Object.

===== $r14.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(
            new Test$AjcClosure1(r4), ajc$tjp_0);  is


    public java.lang.Object 
      ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2(
         org.aspectj.runtime.internal.AroundClosure r1, 
         org.aspectj.lang.JoinPoint$StaticPart r2) 
      throws java.lang.Throwable
    {
        java.lang.Object r3, $r47, $r63;
        java.lang.StringBuffer $r4, r10, r13, r20, r23, r27, r29;
        org.aspectj.lang.JoinPoint$StaticPart r5, r15, r25;
        java.lang.Object[] r6, r8, r11, r14, r16, r18, r21, r24, r26, r28, r30;
        org.aspectj.lang.Signature r7;
        java.lang.String r9, r12, r19, r22;
        org.aspectj.lang.reflect.SourceLocation r17;
        int i0;
        java.io.PrintStream $r31;
        lib.aspects.codingstandards.EnforceCodingStandards $r32, $r36, $r40, $r44, $r48, $r52, $r56, $r60, $r64, $r69, $r74;

        r3 = EnforceCodingStandards.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2proceed(r1);

        if (r3 == null)
        { // Deleted lots of code .... aspect actually applied to all these
          //       calls....  this branch never really taken in benchmark...
          // This is the part that prints the error message to stderr. 
        }

        return r3;
    }

========  EnforceCodingStandards.ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2proceed(r1);  is

    static java.lang.Object 
      ajc$around$lib_aspects_codingstandards_EnforceCodingStandards$8b2proceed(
         org.aspectj.runtime.internal.AroundClosure r0) throws
    java.lang.Throwable, java.lang.ClassNotFoundException
    {
        return (Object) r0.run(new Object[0]);
    }

======== r0.run(new Object[0]);  is  (r0 has runtime type Test$AjcClosure1)

public java.lang.Object run( java.lang.Object[] r1) 
      throws java.lang.ClassNotFoundException, java.lang.Throwable
 { java.lang.Object[] r2;
   r2 = state;
   return Test.incr_aroundBody0((MyInteger) r2[0], Conversions.intValue(r2[1]));
 }

======= Conversions.intValue(r2[1]);   is

 public static int intValue(java.lang.Object r0)
    { if (r0 != null)
        { if (r0 instanceof Number == false)
            { throw new ClassCastException((new StringBuffer()).append(
                r0.getClass().getName()).append(
                " can not be converted to int").toString());
            }
          else
            { return ((Number) r0).intValue();
            }
        }
      else
        { return 0;
        }
    }

======= Test.incr_aroundBody0( ...)  is

   static final MyInteger incr_aroundBody0(MyInteger r0, int i0)
    { return r0.incr(i0);   //******* Ah ha .... the original call!!!
    }

-------------------------------------------------------------------------

If you tally up the work added for each call that has advice put around
it,  you get:

      invokespecial:  2
      invokestatic:   5
      invokevirtual:  2
      arrays allocated and initialized:  2
      objects allocated:  3
      field read/write:  3
      cast/instanceof:   4

plus all the regular bytecodes, that I didn't count.    So, it is no
wonder you get a lot of slowdown.

-------------------------------------------------------------------------

Now, the question is .... what is "overhead" and what is useful work?

Cheers, Laurie
